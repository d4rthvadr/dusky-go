package main

import (
	"database/sql"
	"net/http"
	"net/url"
	"time"

	"github.com/d4rthvadr/dusky-go/internal/auth"
	"github.com/d4rthvadr/dusky-go/internal/config"
	apphttp "github.com/d4rthvadr/dusky-go/internal/http"
	"github.com/d4rthvadr/dusky-go/internal/http/handlers"
	"github.com/d4rthvadr/dusky-go/internal/mailer"
	"github.com/d4rthvadr/dusky-go/internal/store"
	"github.com/d4rthvadr/dusky-go/internal/utils"
	swaggerDocs "github.com/d4rthvadr/dusky-go/swagger" // This line is necessary for go-swagger to find the docs package and generate the swagger documentation. The docs package is generated by go-swagger based on the comments in the main.go file and the handlers.
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
)

type application struct {
	config           AppConfig
	store            store.Storage
	db               *sql.DB
	logger           utils.Logger
	jwtAuthenticator *auth.JWTAuthenticator
	handler          *handlers.Handler
}

type AppConfig struct {
	addr   string
	apiUrl string
}

func (app *application) mount() *chi.Mux {

	r := chi.NewRouter()
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Logger)

	apphttp.MountV1Routes(r, app.handler, app.config.apiUrl)

	return r
}

func (app *application) Run(mux *chi.Mux) error {

	// Docs
	swaggerDocs.SwaggerInfo.Title = "Dusky API"
	swaggerDocs.SwaggerInfo.Description = "This is a sample server for a social media application called Dusky. It provides endpoints for managing users, posts, comments, and feeds."
	swaggerDocs.SwaggerInfo.Version = version
	swaggerHost := app.config.addr
	swaggerSchemes := []string{"http"}

	if parsedAPIURL, err := url.Parse(app.config.apiUrl); err == nil {
		if parsedAPIURL.Host != "" {
			swaggerHost = parsedAPIURL.Host
		}

		if parsedAPIURL.Scheme != "" {
			swaggerSchemes = []string{parsedAPIURL.Scheme}
		}
	}

	swaggerDocs.SwaggerInfo.Host = swaggerHost
	swaggerDocs.SwaggerInfo.BasePath = "/v1"
	swaggerDocs.SwaggerInfo.Schemes = swaggerSchemes

	srv := http.Server{
		Addr:         ":" + app.config.addr,
		Handler:      mux,
		WriteTimeout: time.Second * 30,
		ReadTimeout:  time.Second * 15,
		IdleTimeout:  time.Minute,
	}

	app.logger.Infof("server has started at %s", app.config.addr)

	return srv.ListenAndServe()
}

type appOptions struct {
	config           AppConfig
	store            store.Storage
	db               *sql.DB
	logger           utils.Logger
	mailConfig       config.MailConfig
	mailer           mailer.Client
	jwtAuthenticator *auth.JWTAuthenticator
	isProdEnv        bool
}

func NewApplication(options appOptions) *application {
	return &application{
		config:           options.config,
		store:            options.store,
		db:               options.db,
		logger:           options.logger,
		jwtAuthenticator: options.jwtAuthenticator,
		handler:          handlers.New(options.store, version, options.logger, options.mailConfig, options.mailer, options.jwtAuthenticator, options.isProdEnv),
	}
}
